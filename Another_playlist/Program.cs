using Another_playlist.Data;
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;

namespace Another_playlist
{
	// link of playlist: https://www.youtube.com/playlist?list=PLqPejUavRNTXdgLMPnCwqriZX1yZ_Kgib
	internal class Program
	{
		static IEnumerable<Customer> Customers = Data.Repository.GetCustomers();
		static IEnumerable<CustomerCategory> Categoies = Data.Repository.GetCategories();
		static IEnumerable<Order> Orders = Data.Repository.GetOrders();
		static IEnumerable<CustomerWithCategoryDTO> CustomersWhisCategoies = Customers.Join(Categoies,
				cust => cust.categoryId,
				cat => cat.Id,
				(cust, cat) => new CustomerWithCategoryDTO
				{
					id = cust.id,
					name = cust.name,
					telephone = cust.telephone,
					age = cust.age,
					spendAverage = cust.spendAverage,
					isActive = cust.isActive,
					joinDate = cust.joinDate,
					categoryName = cat.Name
				});

		static void Main(string[] args)
		{
			//AnonymousType();
			//Select();
			//ImmediateExecution();
			//SomeLINQOperators();
			//Join();
			//LeftOrRightJoin();
			//GroupBy();
			//ToLookup();
			//GeneratorOperators();
			//SetAndCasting();
			//Quantifier();
			//MoreLinqOperators();
			//MoreLinqOperatorsPart2();
			//Into();


		}



		static void AnonymousType()
		{
			// 1. Creating Anonymous Types
			// Anonymous types are compiler-generated classes that are defined inline
			// using the 'new' keyword and an object initializer.
			// The property names and types are inferred from the initialization.

			// Creates an anonymous type with two properties: 'name' (string) and 'age' (int).
			var person = new { name = "ahmed", age = 15 };

			// Creates another anonymous type.
			// This has the *same* structure (property names and types: name=string, age=int)
			// as 'person', but different property *values*.
			// The compiler will generate the *same* anonymous type behind the scenes for 'person' and 'person2'.
			var person2 = new { name = "ahmed", age = 16 };

			// Creates a different anonymous type.
			// This has a *different* structure (name=string, age=int, gender=char)
			// compared to 'person' and 'person2' because it has an additional property.
			// The compiler will generate a *different* anonymous type for 'person3'.
			var person3 = new { name = "ahmed", age = 15, gender = 'M' };

			// Creates yet another anonymous type.
			// This has a *different* structure (name=string, age=int, sex=char)
			// compared to 'person3' because, although it has the same number of properties
			// and similar types/values, the *property name* ('sex' vs 'gender') is different.
			// The compiler will generate a *different* anonymous type for 'person4' from 'person3'.
			var person4 = new { name = "ahmed", age = 15, sex = 'M' };

			// 2. Printing Anonymous Types
			// Anonymous types automatically provide a useful default ToString() implementation
			// which displays the names and values of their properties.
			Console.WriteLine(person);
			Console.WriteLine(person2);
			Console.WriteLine(person3);
			Console.WriteLine(person4);

			// 3. Inspecting the Compiler-Generated Type Names
			// .GetType().Name reveals the actual name of the anonymous type generated by the compiler.
			// These names are typically internal and not meant to be used directly in code.
			// Notice that 'person' and 'person2' will have the same type name because they have the same structure.
			// 'person3' and 'person4' will have different type names as their structures differ from the first two
			// and from each other (due to the property name difference between gender and sex).
			Console.WriteLine($"{nameof(person)} " + person.GetType().Name);
			Console.WriteLine($"{nameof(person2)} " + person2.GetType().Name);
			Console.WriteLine($"{nameof(person3)} " + person3.GetType().Name);
			Console.WriteLine($"{nameof(person4)} " + person4.GetType().Name);

			// 4. Anonymous Type Equality (Value Equality)
			// Anonymous types override Equals() and GetHashCode() to provide *value equality*.
			// Two anonymous type instances are considered equal if:
			//   a) They are of the *same* anonymous type (i.e., generated from the same structure).
			//   b) All of their property values are equal.

			// Compares person and person2.
			// They are the *same* anonymous type (same structure).
			// Their property values are compared: name ("ahmed" == "ahmed") is true, age (15 == 16) is false.
			// Since 'age' is different, Equals returns false.
			Console.WriteLine($"person == person2: {person.Equals(person2)}");

			// Compares person and person3.
			// They are *different* anonymous types because their structures are different
			// (person3 has an extra property, 'gender').
			// Anonymous type Equals() generally returns false if the types are not the same.
			Console.WriteLine($"person == person3: {person.Equals(person3)}");

			// Compares person3 and person4.
			// They are *different* anonymous types because their structures are different.
			// Although they have the same number of properties and similar values,
			// the property names ('gender' vs 'sex') cause the compiler to generate different types.
			// Equals returns false.
			Console.WriteLine($"person3 == person4: {person3.Equals(person4)}");

			// can not use Anonymous Type as retuen value or parameter 
		}

		static void Select()
		{
			// it is return a IEnumerable<AnonymousType> 
			var DTOCustomers = Customers.Select(c => new
			{
				CustomerName = c.name,
				CustomerPhone = c.telephone,

			});


			DTOCustomers.Print(nameof(DTOCustomers));

			var DTOCustomersIndexed = Customers.Select((c, index) => new
			{
				index,
				c.name,
				c.telephone,

			});


			DTOCustomersIndexed.Print(nameof(DTOCustomersIndexed));
		}

		static void ImmediateExecution()
		{
			var customersOrderByAge = Customers.OrderBy(c => c.age);

			// Immediate Execution
			var firstCustomer = customersOrderByAge.First();
			firstCustomer.Print(nameof(firstCustomer));


			var lastCustomer = customersOrderByAge.Last();
			lastCustomer.Print(nameof(lastCustomer));


			var firstCustomerHisAgeIs30 = customersOrderByAge.First(c => c.age == 30);
			firstCustomerHisAgeIs30.Print(nameof(firstCustomerHisAgeIs30));


			// Warning: First() throws an exception if no matching element is found.
			// Use FirstOrDefault() when you expect that the list might be empty or no match found.
			var fisrtOrder = Orders.FirstOrDefault(o => o.customerId == firstCustomer.categoryId);

			Console.WriteLine($"\t\t\t{nameof(fisrtOrder)}");
			fisrtOrder.Print(nameof(fisrtOrder));


		}
		static void SomeLINQOperators()
		{
			// get item by index
			var customerAt4 = Customers
				.Select((c, index) => new { index, c })
				.ElementAt(8);
			customerAt4.Print(nameof(customerAt4));

			// Use Single() when you expect exactly one matching element
			// when your business logic requires exactly one matching element
			// Throws InvalidOperationException if no elements or more than one element match the condition.
			var single = Customers
				.Single(c => c.id == 101);
			single.Print(nameof(single));

			// Use SingleOrDefault() when you expect zero or one matching element
			// Returns null (or default value) if no elements match
			// Throws InvalidOperationException if more than one element matches the condition.
			var single2 = Customers
				.SingleOrDefault(c => c.id == 101);
			single.Print(nameof(single2));


			var count = Customers.Count();
			var longCount = Customers.LongCount();

			count.Print(nameof(count));
			longCount.Print(nameof(longCount));


			var countIfActive = Customers.Count(c => c.isActive);
			countIfActive.Print(nameof(countIfActive));


			var maxSpend = Customers.Max(c => c.spendAverage);
			var minSpend = Customers.Min(c => c.spendAverage);

			maxSpend.Print(nameof(maxSpend));
			minSpend.Print(nameof(minSpend));

			var customerHasMaxSpend = Customers.Max(new CompareCustomerBySpendAverage());
			customerHasMaxSpend.Print(nameof(customerHasMaxSpend));

			var customerHasMaxSpendUsingMaxBy = Customers.MaxBy((c) => c.spendAverage);
			customerHasMaxSpendUsingMaxBy.Print(nameof(customerHasMaxSpendUsingMaxBy));

			var averageSpend = Customers.Average(c => c.spendAverage);
			averageSpend.Print(nameof(averageSpend));

			var sumSpend = Customers.Sum(c => c.spendAverage);
			sumSpend.Print(nameof(sumSpend));


		}
		public class CompareCustomerBySpendAverage : IComparer<Customer>
		{
			public int Compare(Customer? x, Customer? y)
			{
				return x.spendAverage.CompareTo(y.spendAverage);
			}
		}
		static void Join()
		{
			var customersWithCategory = Customers.Join(Categoies,
				cust => cust.categoryId,
				cat => cat.Id,
				(cust, cat) => new
				{
					CustomerCategory = cat.Name,
					CustomerName = cust.name,
					cust.categoryId,
					cat.Id,
				});

			customersWithCategory.Print(nameof(customersWithCategory));


			var customersWithCategoryQureySyntax = from cat in Categoies
												   join cus in Customers
												   on cat.Id equals cus.categoryId
												   select new
												   {
													   CustomerCategory = cat.Name,
													   CustomerName = cus.name,
													   cus.categoryId,
													   cat.Id,
												   };

			customersWithCategoryQureySyntax.Print(nameof(customersWithCategoryQureySyntax));
		}
		static void LeftOrRightJoin()
		{
			var LeftJoin = Categoies.GroupJoin(Customers,
				cat => cat.Id,
				cust => cust.categoryId,
				(cat, cust) => new
				{
					Category = cat.Name,
					Customers = cust,

				});
			// Left join
			foreach (var item in LeftJoin)
			{
				Console.WriteLine(item.Category);
				foreach (var item1 in item.Customers)
				{
					Console.WriteLine($">>>>>>{item1.name}");
				}
			}
			Console.WriteLine("----------------------");

			var RightJoin = Customers.GroupJoin(Categoies,
				cust => cust.categoryId,
				cat => cat.Id,
				(cust, cat) => new
				{
					Categories = cat,
					CustomersName = cust.name,

				});
			// Right join
			foreach (var item in RightJoin)
			{
				Console.WriteLine(item.CustomersName);
				foreach (var item1 in item.Categories)
				{
					Console.WriteLine($">>>>>>{item1.Name}");
				}
			}

			Console.WriteLine("-------------------------");


			var LeftJoinQureySyntax = from cat in Categoies
									  join cus in Customers
									  on cat.Id equals cus.categoryId
									  into custs
									  select new
									  {
										  Category = cat.Name,
										  Customers = custs,
									  };

			foreach (var item in LeftJoinQureySyntax)
			{
				Console.WriteLine(item.Category);
				foreach (var item1 in item.Customers)
				{
					Console.WriteLine($">>>>>>{item1.name}");
				}
			}
		}

		static void GroupBy()
		{
			// Deferred Execution
			// retrun IEnumerable type 
			var customerGroupingByCategoryId = Customers.GroupBy(c => c.categoryId);
			foreach (var item in customerGroupingByCategoryId)
			{
				item.Key.Print($"{item.Key}");
				foreach (var item1 in item)
				{
					Console.WriteLine("----------" + item1.name);
				}
			}
			var customerGroupingByCategoryName = CustomersWhisCategoies.GroupBy(c => c.categoryName);
			foreach (var item in customerGroupingByCategoryName)
			{
				item.Key.Print($"{item.Key}");
				foreach (var item1 in item)
				{
					Console.WriteLine("----------" + item1.name);

				}
			}

			var customerGroupingByCategoryIdQureySyntax = from c in Customers
														  group c by c.categoryId;
		}
		static void ToLookup()
		{
			// Immediate Execution
			// return Lookup type 
			var customerGroupingByCategoryId = Customers.ToLookup(c => c.categoryId);
			foreach (var item in customerGroupingByCategoryId)
			{
				item.Key.Print($"{item.Key}");

				foreach (var item1 in item)
				{
					Console.WriteLine("----------" + item1.name);
				}
			}
			var customerGroupingByCategoryName = CustomersWhisCategoies.ToLookup(c => c.categoryName);
			foreach (var item in customerGroupingByCategoryName)
			{
				item.Key.Print($"{item.Key}");
				foreach (var item1 in item)
				{
					Console.WriteLine("----------" + item1.name);

				}
			}


		}
		static void GeneratorOperators()
		{
			// Generate data
			// not extnension method

			var rangeFrom1To10 = Enumerable.Range(1, 10);

			rangeFrom1To10.Print(nameof(rangeFrom1To10));

			var emptyCustomer = Enumerable.Empty<Customer>();

			emptyCustomer.Print(nameof(emptyCustomer));

			var repeatAhmed4Times = Enumerable.Repeat("ahmed", 5);

			repeatAhmed4Times.Print(nameof(repeatAhmed4Times));
		}
		static void SetAndCasting()
		{
			Customer[] customersArray = Customers.Where(c => c.categoryId == 1)
				.ToArray();

			List<Customer> customersList = Customers.Where(c => c.categoryId == 1)
				.ToList();

			Dictionary<int, IEnumerable<Customer>> customersDictionary = Customers.GroupBy(c => c.categoryId)
				.ToDictionary(c => c.Key, c => c.AsEnumerable());


			foreach (var item in customersDictionary)
			{
				item.Value.Print($"{item.Key}");
			}

			var l1 = Enumerable.Range(0, 10);
			var l2 = Enumerable.Range(5, 15);

			var listUnion = l1.Union(l2);

			listUnion.Print(nameof(listUnion));

			var listConcat = l1.Concat(l2);

			listConcat.Print(nameof(listConcat));

			var listConcatDistinct = listConcat.Distinct();

			listConcatDistinct.Print(nameof(listConcatDistinct));

			var listExcept = l1.Except(l2);

			listExcept.Print(nameof(listExcept));

			var listIntersect = l1.Intersect(l2);

			listIntersect.Print(nameof(listIntersect));

		}
		static void Quantifier()
		{
			var isAllCustomersAgeAboveThen15 = Customers.All(c => c.age > 15);
			isAllCustomersAgeAboveThen15.Print(nameof(isAllCustomersAgeAboveThen15));

			var isAllCustomersAgeAboveThen20 = Customers.All(c => c.age > 20);
			isAllCustomersAgeAboveThen20.Print(nameof(isAllCustomersAgeAboveThen20));

			var isAnyOfCustomersAgeAboveThen20 = Customers.Any(c => c.age > 20);
			isAnyOfCustomersAgeAboveThen20.Print(nameof(isAnyOfCustomersAgeAboveThen20));

			var isHaveCustomers = Customers.Any();
			isHaveCustomers.Print(nameof(isHaveCustomers));

			var isNotempty = new List<int>().Any();
			isNotempty.Print(nameof(isNotempty));

			var someCustomer = new Customer { id = 108, name = "sayed kabaka", age = 39, isActive = true, joinDate = new DateTime(2023, 4, 8), categoryId = 2, spendAverage = 1800.4m, telephone = 123698789 };

			var isCustomersContainsSomeCustomer = Customers.Contains(someCustomer, new EqualityTowCustomers());

			isCustomersContainsSomeCustomer.Print(nameof(isCustomersContainsSomeCustomer));

		}

		class EqualityTowCustomers : IEqualityComparer<Customer>
		{

			public bool Equals(Customer? x, Customer? y)
			{
				var type = typeof(Customer);
				foreach (var info in type.GetProperties())
				{

					var valueX = info.GetValue(x);
					var valueY = info.GetValue(y);

					if (!valueX.Equals(valueY))
					{
						return false;
					}

				}
				return true;
			}


			public int GetHashCode([DisallowNull] Customer obj)
			{
				return obj.id.GetHashCode();
			}
		}

		static void MoreLinqOperators()
		{
			var l1 = new List<int> { 1, 2, 3, 4, 5, 6, 7 };
			var l2 = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8 };

			var res = l1.SequenceEqual(l2);
			res.Print(nameof(res));

			var l3 = new List<int> { 1, 2, 3, 4, 5, 6, 7 };
			var l4 = new List<int> { 1, 2, 3, 4, 5, 6, 7 };

			var res2 = l3.SequenceEqual(l4);
			res2.Print(nameof(res2));
		}
		static void MoreLinqOperatorsPart2()
		{
			// Aggregate combines all elements into a single result based on a custom logic
			var discounts = Customers.Aggregate<Customer, string>
				("discount is: ", (s, c) =>
				{

					s += $"\ndiscount {(c.spendAverage * 0.5m)} for customer {c.name}";
					return s;
				});



			discounts.Print(nameof(discounts));

			var sumOfRange50 = Enumerable.Range(1, 5).Aggregate(0, (seed, n) =>
			{

				seed += n;
				return seed;
			});

			sumOfRange50.Print(nameof(sumOfRange50));

			var lis = new List<int>();
			var defaultValues = lis.DefaultIfEmpty();
			defaultValues.Print(nameof(defaultValues));
		}

		static void Into()
		{

			List<string> names = new List<string>()
				{ "@hmed" , "Mo&ed", "3alah"  };

			var res = from n in names
					  select Regex.Replace(n, "[@&3]", "_")
					  into newN // can not use n
					  where newN.ToLower().Contains('m')
					  orderby newN.Length
					  select newN;

			var res2 = from n in names
					   let newN = Regex.Replace(n, "[@&3]", "_")
					   where newN.ToLower().Contains('m')
					   orderby newN.Length, n.Length
					   select newN;
		}


	}
}


